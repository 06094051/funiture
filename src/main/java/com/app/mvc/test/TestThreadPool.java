package com.app.mvc.test;import com.google.common.collect.Maps;import lombok.extern.slf4j.Slf4j;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ConcurrentMap;import java.util.concurrent.FutureTask;import java.util.concurrent.RejectedExecutionHandler;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * Created by jimin on 16/3/21. */@Slf4jpublic class TestThreadPool {    private static ConcurrentMap<Integer, ThreadPoolExecutor> threadPoolExecutorMap = Maps.newConcurrentMap();    public static void main(String[] args) throws Exception {        for (int i = 0; i < 3000; i++) {            threadPoolExecutorMap.put(i, newDefaultExecutor());        }        log.info("start!");        for (int j = 1; j < 10; j++) { // 取线程池            final int t = j;            for (int p = 1; p < 100; p++) { // 100个线程                try {                    log.info("init thread, {}-{}", j, p);                    threadPoolExecutorMap.get(t).submit(new HttpWorker(t + "---" + p));                } catch (Throwable e) {                    log.error("reject", e);                }            }            log.info("j = {}", j);        }        Thread.sleep(100000);    }    private static ThreadPoolExecutor newDefaultExecutor() {        //log.info("init default");        return new ThreadPoolExecutor(2,              // 核心池大小                5,                                    // 最大线程数                1200,                                 // 空闲等待时间                TimeUnit.SECONDS,                     // 时间单位                new ArrayBlockingQueue<Runnable>(100), // 循环数组 + 指定大小                new DiscardOldestPolicy()             // 最早的丢弃, 可以根据需要调整        );    }    public static class DiscardOldestPolicy implements RejectedExecutionHandler {        public DiscardOldestPolicy() {        }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {            if (!e.isShutdown()) {                FutureTask<HttpWorker> worker = (FutureTask) e.getQueue().poll();                e.execute(r);                try {                    String c = worker.get().getC();                    log.info(" c = {}", c);                } catch (Exception e2) {                    log.error("er....", e2);                }            } else {                log.error("r is empty");            }        }    }    private static class HttpWorker implements Runnable {        private String c;        public HttpWorker(String c) {            this.c = c;        }        public String getC() {            return c;        }        @Override        public void run() {            double sum = 0;            for (int q = 0; q < 10000; q++) {                sum += q;            }            log.info("c:{}, sum: {}", c, sum);        }    }}